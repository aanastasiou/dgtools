.EQU status_reg=252
.EQU zero_bit=0
.EQU carry_bit=1
.EQU pixel_bit=3

# Initialise the framebuffer
COPYLA framebuffer 
ADDRA framebuffer_offset
COPYAR framebuffer_offset

BSET pixel_bit status_reg

# Draw characters 
COPYLR 0 X
COPYLR 0 Y
COPYLR 1 SX
COPYLR 0 SY
COPYLR 16 Q0
CALL draw_line
COPYLR 0 X
COPYLR 0 Y
COPYLR 0 SX
COPYLR 1 SY
COPYLR 4 Q0
CALL draw_line
COPYLR 0 X
COPYLR 4 Y
COPYLR 1 SX
COPYLR 0 SY
COPYLR 16 Q0
CALL draw_line
HALT

draw_line:
CALL set_pixel
COPYRA X
BCLR carry_bit status_reg
ADDRA SX
COPYAR X
COPYRA Y
BCLR carry_bit status_reg
ADDRA SY
COPYAR Y
DECR Q0
BTSTSS zero_bit status_reg
JUMP draw_line
RETURN

set_pixel:
COPYRR X R0
DIV R0 R1   # Divide by 8
COPYAR pix_bit   # Modulo in R1
COPYRA R0   # Division in R0, shift it to Acc
COPYRR framebuffer_X_dim R0 
MUL R0 Y    # Multiply xdim by the x to locate the byte
BCLR carry_bit status_reg
ADDRA R0    # Add the byte offset
ADDRA framebuffer_offset # Add the framebuffer offset
COPYAR pix_addr   # Send the result to R2
BTSTSC pixel_bit status_reg
JUMP set_pixel_on
JUMP set_pixel_off
set_pixel_on:
COPYLR 36 pix_command
JUMP set_pixel_apply
set_pixel_off:
COPYLR 35 pix_command
set_pixel_apply:
CALL pix_command
RETURN

Q0:     # Tracks the length of the line
.DB 0
R0:
.DB 0
R1:
.DB 8
SX:
.DB 0
SY:
.DB 0
X:
.DB 0
Y:
.DB 0
pix_command:
.DB 36
pix_bit:
.DB 0
pix_addr:
,DB 0
RETURN
framebuffer_X_dim:
.DB 8
framebuffer_offset:
.DB 9
framebuffer:
.DB 0
