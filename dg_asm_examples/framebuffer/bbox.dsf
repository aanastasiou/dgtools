# Stare at the code long enough
# the code stares back at you.
#
# Establishes a framebuffer and 
# set_pixel, draw_line operations 
# and uses these to draw ASC(1) on
# whatever RAM remains available.

# Can be further optimised.

.EQU status_reg=252
.EQU zero_bit=0
.EQU carry_bit=1
.EQU pixel_bit=3

# Initialise the framebuffer
COPYLA framebuffer 
ADDRA framebuffer_offset
COPYAR framebuffer_offset

BSET pixel_bit status_reg

# Draw the "face" 
# Top of the head
COPYLR 0 X
COPYLR 0 Y
COPYLR 1 SX
COPYLR 0 SY
COPYLR 7 Q0
CALL draw_line

# Left side
COPYLR 0 X
COPYLR 1 Y
COPYLR 0 SX
COPYLR 1 SY
COPYLR 5 Q0
CALL draw_line

# Right side
COPYLR 0 X
COPYLR 6 Y
COPYLR 1 SX
COPYLR 0 SY
COPYLR 7 Q0
CALL draw_line

# Bottom of the head
COPYLR 6 X
COPYLR 1 Y
COPYLR 0 SX
COPYLR 1 SY
COPYLR 5 Q0
CALL draw_line

# Mouth line
COPYLR 2 X
COPYLR 4 Y
COPYLR 1 SX
COPYLR 0 SY
COPYLR 3 Q0
CALL draw_line

# Left eye
COPYLR 2 X
COPYLR 2 Y
CALL set_pixel

# Right eye
COPYLR 4 X
COPYLR 2 Y
CALL set_pixel
HALT

draw_line:
# Draws a line as defined by 
# a starting position (X,Y)
# individual X, Y steps (SX,SY)
# length (Q0)
# and line color (pixel_bit field
# of the status register).
CALL set_pixel
COPYRA X
BCLR carry_bit status_reg
ADDRA SX
COPYAR X
COPYRA Y
BCLR carry_bit status_reg
ADDRA SY
COPYAR Y
DECR Q0
BTSTSS zero_bit status_reg
JUMP draw_line
RETURN

set_pixel:
# Sets a pixel to the bit value 
# in (pixel_bit), taking care of 
# the framebuffer addressing.
# 
# The framebuffer is a row major
# binary array composed of 8 bytes
# horizontally and the remaining
# RAM vertically.
COPYRR X R0
DIV R0 R1   # Divide by 8
COPYAR pix_bit   # Modulo in R1
COPYRA R0   # Division in R0, shift it to Acc
COPYRR framebuffer_X_dim R0 
MUL R0 Y    # Multiply xdim by the x to locate the byte
BCLR carry_bit status_reg
ADDRA R0    # Add the byte offset
ADDRA framebuffer_offset # Add the framebuffer offset
COPYAR pix_addr   # Send the result to R2
BTSTSC pixel_bit status_reg
JUMP set_pixel_on
JUMP set_pixel_off
set_pixel_on:
COPYLR 36 pix_instruction
JUMP set_pixel_apply
set_pixel_off:
COPYLR 35 pix_instruction
set_pixel_apply:
CALL pix_instruction
RETURN

Q0:     # Tracks the length of the line
.DB 0
R0:
.DB 0
R1:
.DB 8
SX:     # Step X of the line
.DB 0
SY:     # Step Y of the line
.DB 0
X:      # Initial X pos
.DB 0
Y:      # Initial Y pos
.DB 0
pix_instruction:
.DB 36
pix_bit:
.DB 0
pix_addr:
,DB 0
RETURN
framebuffer_X_dim: # The X dim of the buffer
.DB 8
framebuffer_offset: # Offset from framebuffer
.DB 6
framebuffer:        # Where framebuffer starts
.DB 0
