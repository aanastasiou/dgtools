.EQU status_reg=252
.EQU zero_bit=0
.EQU carry_bit=1
.EQU pixel_bit=3

.EQU slash_length=3

# Initialise the framebuffer
COPYLA framebuffer 
ADDRA framebuffer_offset
COPYAR framebuffer_offset

BSET pixel_bit status_reg

# Draw characters 
COPYLR 0 X
COPYLR 0 Y
draw_next_char:
RANDA
COPYAR R0
BTSTSS 1 R0
JUMP ds
dbs:
CALL draw_backslash
JUMP continue
ds:
CALL draw_slash
continue:
COPYRR Q1 Y
INCR X
COPYLA 24
BCLR carry_bit status_reg
SUBRA X
BTSTSC zero_bit status_reg
CALL reset_y
JUMP draw_next_char
HALT

reset_y:
INCR Y
INCR Y
INCR Y
COPYLR 0 X
COPYRR Y Q1
RETURN


draw_slash:
INCR Y
INCR Y
COPYLR 255 SY
COPYLR 1 SX
COPYLR slash_length Q0
CALL draw_line
RETURN

draw_backslash:
COPYLR 1 SY
COPYLR 1 SX
COPYLR slash_length Q0
CALL draw_line
RETURN

draw_line:
CALL set_pixel
COPYRA X
BCLR carry_bit status_reg
ADDRA SX
COPYAR X
COPYRA Y
BCLR carry_bit status_reg
ADDRA SY
COPYAR Y
DECR Q0
BTSTSS zero_bit status_reg
JUMP draw_line
RETURN

set_pixel:
COPYRR X R0
DIV R0 R1   # Divide by 8
COPYAR pix_bit   # Modulo in R1
COPYRA R0   # Division in R0, shift it to Acc
COPYRR framebuffer_X_dim R0 
MUL R0 Y    # Multiply xdim by the x to locate the byte
BCLR carry_bit status_reg
ADDRA R0    # Add the byte offset
ADDRA framebuffer_offset # Add the framebuffer offset
COPYAR pix_addr   # Send the result to R2
BTSTSC pixel_bit status_reg
JUMP set_pixel_on
JUMP set_pixel_off
set_pixel_on:
COPYLR 36 pix_command
JUMP set_pixel_apply
set_pixel_off:
COPYLR 35 pix_command
set_pixel_apply:
CALL pix_command
RETURN

Q0:     # Tracks the length of the line
.DB 0
Q1:
.DB 0
R0:
.DB 0
R1:
.DB 8
SX:
.DB 0
SY:
.DB 0
X:
.DB 0
Y:
.DB 0
pix_command:
.DB 36
pix_bit:
.DB 0
pix_addr:
,DB 0
RETURN
framebuffer_X_dim:
.DB 8
framebuffer_offset:
.DB 1
framebuffer:
.DB 0
