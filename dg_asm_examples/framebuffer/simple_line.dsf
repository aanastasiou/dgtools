# Draws a small maze composed of 
# slash and backslash characters 

# Expands on the bbox example, by 
# using the line "primitive" to 
# draw the slash and backslash.

# Positions slashes and backslashes 
# randomly to create the maze as per
# the wonderful:
# 10print.org

# Can be optimised further.

# General declarations
.EQU status_reg=252  # The status register
.EQU zero_bit=0      # Zero bit field
.EQU carry_bit=1     # Carry bit field
.EQU pixel_bit=3     # Pixel color 

.EQU slash_length=3  # Length of the chars

# Initialise the framebuffer
COPYLA framebuffer 
ADDRA framebuffer_offset
COPYAR framebuffer_offset

# Set the pixel color (to ON)
BSET pixel_bit status_reg

# Draw characters
# Set the initial position of 
# the "cursor" 
COPYLR 0 X
COPYLR 0 Y
draw_next_char:
# Generate a random number
# and use one of its bits
# to decide which character to 
# print next (0:Slash, 1:Backslash)
RANDA
COPYAR R0
BTSTSS 1 R0
JUMP ds
dbs:
CALL draw_backslash
JUMP continue
ds:
CALL draw_slash
continue:
# Adjust the cursor and move on
COPYRR Q1 Y
INCR X
COPYLA 24
BCLR carry_bit status_reg   
SUBRA X
BTSTSC zero_bit status_reg  # Check if end-of-line
CALL reset_y
JUMP draw_next_char
HALT

reset_y:
# Moves the cursor to the next line
INCR Y
INCR Y
INCR Y
COPYLR 0 X
COPYRR Y Q1
RETURN


draw_slash:
# A slash starts from bottom-left and
# ends top right.
# This is why the current Y needs to be 
# readjusted here.
INCR Y
INCR Y
COPYLR 255 SY
COPYLR 1 SX
COPYLR slash_length Q0
CALL draw_line
RETURN

draw_backslash:
# A backslash starts from the top left and ends 
# at the bottom right pixel.
COPYLR 1 SY
COPYLR 1 SX
COPYLR slash_length Q0
CALL draw_line
RETURN

draw_line:
# Draws a line as defined by 
# a starting position (X,Y)
# individual X, Y steps (SX,SY)
# length (Q0)
# and line color (pixel_bit field
# of the status register).
CALL set_pixel
COPYRA X
BCLR carry_bit status_reg
ADDRA SX
COPYAR X
COPYRA Y
BCLR carry_bit status_reg
ADDRA SY
COPYAR Y
DECR Q0
BTSTSS zero_bit status_reg
JUMP draw_line
RETURN

set_pixel:
# Sets a pixel to the bit value 
# in (pixel_bit), taking care of 
# the framebuffer addressing.
# 
# The framebuffer is a row major
# binary array composed of 8 bytes
# horizontally and the remaining
# RAM vertically.
COPYRR X R0
DIV R0 R1   # Divide by 8
COPYAR pix_bit   # Modulo in R1
COPYRA R0   # Division in R0, shift it to Acc
COPYRR framebuffer_X_dim R0 
MUL R0 Y    # Multiply xdim by the x to locate the byte
BCLR carry_bit status_reg
ADDRA R0    # Add the byte offset
ADDRA framebuffer_offset # Add the framebuffer offset
COPYAR pix_addr   # Send the result to R2
BTSTSC pixel_bit status_reg
JUMP set_pixel_on
JUMP set_pixel_off
set_pixel_on:
COPYLR 36 pix_instruction
JUMP set_pixel_apply
set_pixel_off:
COPYLR 35 pix_instruction
set_pixel_apply:
CALL pix_instruction
RETURN

Q0:     # Tracks the length of the line
.DB 0
Q1:     # General purpose
.DB 0
R0:
.DB 0
R1:
.DB 8
SX:     # Step X of the line
.DB 0
SY:     # Step Y of the line
.DB 0
X:      # Initial X pos
.DB 0
Y:      # Initial Y pos
.DB 0

pix_instruction:
# This is a very simple bitset
# operation for the specific 
# bit (pix_bit) within the specific 
# byte (pix_addr) of the framebuffer
.DB 36
pix_bit:
.DB 0
pix_addr:
,DB 0
RETURN
framebuffer_X_dim:  # The X dim of the framebuffer
.DB 8
framebuffer_offset: # Offset from (framebuffer)
.DB 1
framebuffer:        # The actual start of the framebuffer
.DB 0
