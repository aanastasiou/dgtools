# One huge ripple counter

# The main idea behind this program was to write the 
# smallest program possible, using the most memory 
# possible.

# The program is making use of some self-modifying code 
# to produce an INCR indirect: An INCR instruction that 
# increases the value of a specific memory location.

# The counter is initialised at a very special occasion:
# It is about to reset itself from its maximum count back 
# down to 0. This creates a rippling effect as the reset 
# ripple travels from the Least Significant Byte (LSB) to 
# the Most Significant Byte (MSB).
 
# This counter is 224 BYTES long and the highest number it 
# can represent is:

# 27909511162785237640782267391806507290588793534566025261
# 59895194880296612786049947897011013678758595218495247933
# 82568057369148405837577299984720398976429790087982805274
# 89343740678871610345486763520814415774991266865700608522
# 61602618088414848627032577719797139238638200387296375209
# 89894984676774385364934677289947762340313157123529922421
# 73873816239223375650766633979967525700253935661974708017
# 67864967326798547831855832338782342703700659546152214431
# 90595445898747930123678952192875629172092437548194134594
# 886873249778512829119416327938768895

.EQU status_register=252        # Status register
.EQU zero_bit=0                 # Zero bit of the status reg

count_again:
COPYLR counter incr_addr        # Sets the target of INCR to incr (the LSB)
CALL incr_ind                   # Increases the LSB

count_higher:
BCRSS zero_bit status_register
JUMP count_again                # As soon as the LSB resets, increase 
INCR incr_addr                  # its most immediate MSB...
COPYRA incr_addr
SUBLA 253                       # Check if the counter has reached its maximum
BCRSC zero_bit status_register  # addressable byte and wrap around if it has.
JUMP count_again
CALL incr_ind                   # ...and keep rippling up the orders
JUMP count_higher               # of magnitude

# Indirect INCR
# Set incr_addr then call incr_ind
incr_ind:
.DB 19
incr_addr:
.DB 0
RETURN

# Start of the counter state
counter:
.DB 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF 
.DB 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF 
.DB 0xFF, 0xFF, 0xFF, 0xFF
.DB 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF 
.DB 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF 
.DB 0xFF, 0xFF, 0xFF, 0xFF
.DB 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF 
.DB 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF 
.DB 0xFF, 0xFF, 0xFF, 0xFF
.DB 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF 
.DB 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF 
.DB 0xFF, 0xFF, 0xFF, 0xFF
.DB 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF 
.DB 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF 
.DB 0xFF, 0xFF, 0xFF, 0xFF
.DB 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF 
.DB 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF 
.DB 0xFF, 0xFF, 0xFF, 0xFF
.DB 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF 
.DB 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF 
.DB 0xFF, 0xFF, 0xFF, 0xFF
.DB 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF 
.DB 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF 
.DB 0xFF, 0xFF, 0xFF, 0xFF
.DB 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF 
.DB 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF 
.DB 0xFF, 0xFF, 0xFF, 0xFF
.DB 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF 
.DB 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF 
.DB 0xFF, 0xFF, 0xFF, 0xFF
.DB 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF 
.DB 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF 
.DB 0xFF, 0xFF, 0xFF, 0xFF
.DB 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF 
.DB 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF 
.DB 0xFF, 0xFF, 0xFF, 0xFF
.DB 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF 
.DB 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF 
.DB 0xFF, 0xFF, 0xFF, 0xFF
.DB 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF 
.DB 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF 
.DB 0xFF, 0xFF, 0xFF, 0xFF
