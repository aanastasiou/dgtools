# Find the minimum of a list of integers

.EQU status_reg=252
.EQU carry_bit=1
.EQU zero_bit=0

COPYLR 1 R4
COPYLR 0 R5
index_loop:
CALL f_find_min
# Swap the minimum for the current position
COPYLA num_array
ADDRA R5
COPYAR f_from
COPYLR R6 f_to
CALL f_copy_ind
COPYAR f_to
COPYLA num_array
ADDRA R2
COPYAR f_from
CALL f_copy_ind
COPYAR f_to
COPYLR R6 f_from
CALL f_copy_ind
INCR R5  
INCR R4
COPYRA R4
SUBLA 7
BCRSS zero_bit status_reg
JUMP index_loop
HALT


# R0 Is the iteration bounded var
# R1 Is the current min value of the array
# R2 Is the index of the current value
# R3 Is the current value from index
# R4 is the begin index
f_find_min:
COPYRR R4 R0
COPYLA num_array
ADDRA R0
COPYAR f_from
COPYLR R1 f_to
CALL f_copy_ind
COPYRR R0 R2
loop_start:
COPYLA num_array
ADDRA R0
COPYAR f_from
COPYLR R3 f_to
CALL f_copy_ind
# Now R3 has the next number at offset R0 from label num_array
# Compare it with the currently assumed minimum
COPYRA R3
SUBRA R1
BCRSC carry_bit status_reg
CALL mark_new_min
INCR R0
COPYRA R0
SUBLA 8
BCRSS zero_bit status_reg
JUMP loop_start
RETURN

mark_new_min:
COPYRR R0 R2
COPYRR R3 R1
RETURN


f_copy_ind:
# Performs an indirect copy between the addresses pointed to by `f_from, f_to`.
# This also shows a "template" function. It is constructed and parametrised in 
# memory prior to being called from the main program.
.DB 7   # COPYRR opcode
f_from:
.DB 0
f_to:
.DB 0
RETURN

num_array:
.DB 10,132,8,12,150,9,1,4,192,200,0,0,0,0,0,0,0,0,0,0,0,0,0,0

R0:
.DB 0
R1:
.DB 0 
R2:
.DB 0
R3:
.DB 0
R4:
.DB 0
R5:
.DB 0
R6:
.DB 0
