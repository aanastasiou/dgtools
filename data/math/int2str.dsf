# int2str: Converts a byte to its string representation
# The conversion routine is very simple and involves two steps:
#    1. Decompose the number 
#    2. Synthesize a "string"

.EQU status_reg=252

# Program Entry Point
# Test the ascii to string
COPYLR 255 r0
COPYLR ascii_str r1
CALL int2str
HALT


int2str:
# Transforms an integer to an ASCII representation
# Input:
#    r0: int
#    r1: Address of the first byte of the string
# Note:
#    The Digirule2 does not understand the string data type. In this 
#    example, a "string" is just three sequential bytes in memory, 
#    starting at the memory address indicated by register r1.
#
# Save the arguments
COPYRR r0 t0
COPYRR r1 t1
# Divide by 100
COPYRA r0
COPYLR 100 r0
CALL div
# Adjust the ascii rep and copy to the next available string position
CALL int2str_adjust_and_copy
# Load the remainder, divide by 10 
COPYRA r0
COPYLR 10 r0
CALL div
CALL int2str_adjust_and_copy
# Load the remainder
# Notice here, the remainder is in r0 but it does not 
# go through the division. For this reason, it is simply
# copied across from r0 to r1 to be able to re_use the 
# adjust_and_copy procedure as is.
COPYRR r0 r1
CALL int2str_adjust_and_copy
RETURN
int2str_adjust_and_copy:
# Adds the ascii 0 value (48) to the order of mag multiplier 
# and puts the result to the next available string position
COPYRA r1
ADDLA 48
COPYAR t2
COPYLR t2 cpy_from
COPYRR t1 cpy_to
CALL cpy_ind
INCR t1
RETURN

div:
# Performs Acc/r0
# Returns r1:Ratio, r0:Remainder
CBR 0 status_reg # Zero bit
CBR 1 status_reg # Carry bit
COPYLR 0 r1
sub_again:
INCR r1
SUBRA r0
# Check if the last SUB hit zero 
BCRSS 0 status_reg
JUMP check_carry
JUMP sub_again
check_carry:
# Maybe the last SUB overshot zero
BCRSS 1 status_reg
JUMP sub_again
# Adjust results
ADDRA r0
DECR r1
COPYAR r0
RETURN

cpy_ind:
# Indirect copy
.DB 7     # Digirule2 ASM COPYRR opcode
cpy_from:
.DB 0
cpy_to:
.DB 0
RETURN

# General Registers
r0:
.DB 0
r1:
.DB 0
t0:
.DB 0
t1:
.DB 0
t2:
.DB 0
ascii_str:
.DB 0,0,0
