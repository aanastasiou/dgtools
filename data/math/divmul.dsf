# int2str: Converts a byte to its string representation
# The conversion routine is very simple and involves two steps:
#    1. Decompose the number 
#    2. Synthesize a "string"

.EQU status_reg=252

# Program Entry Point
# Test the ascii to string
# COPYLR 176 r0
# COPYLR ascii_str r1
# CALL int2str
# HALT

# Test the half multiplication
COPYLR 8 r0
COPYLR 6 r1
CALL mul
COPYLR ascii_str r1
CALL int2str
HALT

int2str:
# Transforms an integer to an ASCII representation
# Input:
#    r0: int
#    r1: Address of the first byte of the string
# Note:
#    The Digirule2 does not understand the string datatype. In this 
#    example, a "string" is just three bytes that are concatenated 
#    together in one value.
#
# Save the arguments
COPYRR r0 t0
COPYRR r1 t1
# Divide by 100
COPYRA r0
COPYLR 100 r0
CALL div
# Adjust the ascii rep and copy to the next available string position
CALL int2str_adjust_and_copy
# Load the remainder, divide by 10 
COPYRA r0
COPYLR 10 r0
CALL div
CALL int2str_adjust_and_copy
# Load the remainder
# Notice here, the remainder is in r0 but it does not 
# go through the division. For this reason, it is simply
# copied across from r0 to r1 to be abel to re_use the 
# adjust_and_copy procedure as is.
COPYRR r0 r1
CALL int2str_adjust_and_copy
RETURN
int2str_adjust_and_copy:
# Adds the ascii 0 value (48) to the order of mag multiplier 
# and puts the result to the next available string position
COPYRA r1
ADDLA 48
COPYAR t2
COPYLR t2 cpy_from
COPYRR t1 cpy_to
CALL cpy_ind
INCR t1
RETURN


mul:
# Performs r0*r1
# Returns r0:Product
CBR 0 status_reg # Zero bit
CBR 1 status_reg # Carry bit
COPYLA 0
COPYLR 4 t0
mul_add_start:
BCRSS 0 r1
JUMP mul_con
mul_add:
ADDRA r0
mul_con:
SHIFTRL r0
CBR 1 status_reg
SHIFTRR r1
CBR 1 status_reg
DECRJZ t0
JUMP mul_add_start
COPYAR r0
RETURN


div:
# Performs Acc/r0
# Returns r1:Ratio, r0:Remainder
CBR 0 status_reg # Zero bit
CBR 1 status_reg # Carry bit
COPYLR 0 r1
sub_again:
INCR r1
SUBRA r0
# Check if the last SUB hit zero 
BCRSS 0 status_reg
JUMP check_carry
JUMP sub_again
check_carry:
# Maybe the last SUB overshot zero
BCRSS 1 status_reg
JUMP sub_again
# Adjust results
ADDRA r0
DECR r1
COPYAR r0
RETURN

cpy_ind:
# Indirect copy
.DB 7     # Digirule2 ASM COPYRR opcode
cpy_from:
.DB 0
cpy_to:
.DB 0
RETURN

cpylwacc:
COPYRR r0 wacc_h
COPYRR r1 wacc_l
RETURN

 

# General Registers
r0:
.DB 0
r1:
.DB 0
t0:
.DB 0
t1:
.DB 0
t2:
.DB 0

wacc:
wacc_h:
.DB 0
wacc_l:
.DB 0

ascii_str:
.DB 0,0,0
