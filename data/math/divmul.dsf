# int2str: Converts a byte to its string representation
# The conversion routine is very simple and involves two steps:
#    1. Decompose the number 
#    2. Synthesize a "string"

.EQU status_reg=252
# Initialise
COPYLR stack stack_ptr

# Program Entry Point
# COPYLR 129 r0
# COPYLR 0 r1
# COPYLR 2 r2
# COPYLR 0 r3
# CALL mul_wacc

COPYLR 0 wacc_l
COPYLR 2 wacc_h
COPYLR 1 r0
COPYLR 0 r1
CALL sublwacc
HALT

wdiv:
# Performs wacc/r1r0
# Returns r1r0:Ratio, r3r2:Remainder
CBR 0 status_reg # Zero bit
CBR 1 status_reg # Carry bit
COPYLR 0 r3
COPYLR 0 r2
sub_again:
# Save the wide accumulator
CALL incr_r3r2 # Increase by one
CALL sublwacc # Subtract the dividend
# Check if the last SUB hit zero 
BCRSS 0 status_reg
JUMP check_carry
JUMP sub_again
check_carry:
# Maybe the last SUB overshot zero
BCRSS 1 status_reg
JUMP sub_again
# Adjust results
ADDRA r0
DECR r1
COPYAR r0
RETURN

incr_r3r2:
# Increases r3r2 by 1
# Save the accumulator and r1r0
COPYRR wacc_l t4
COPYRR wacc_h t5
COPYRR r0 t2
COPYRR r1 t3
# Load the wide accumulator
COPYRR r3 wacc_h
COPYRR r2 wacc_l
COPYLR 0 r1
COPYLR 1 r0
CALL addlwacc
COPYRR wacc_l r2
COPYRR wacc_h r3
# Restore
COPYRR t3 r1
COPYRR t2 r0
COPYRR t5 wacc_h
COPYRR t4 wacc_l
RETURN

mul_wacc:
# Performs r1r0*r3r2 using the wide accumulator
# NOTE: This is still 8bit multiplication but the function
# might potentially use the full length of both registers.
# Returns the product in the wide accumulator
CBR 0 status_reg # Zero bit
CBR 1 status_reg # Carry bit
# Clear the wide accumulator
COPYLR 0 wacc_l
COPYLR 0 wacc_h
COPYLR 8 t0
mul_add_start_wacc:
BCRSS 0 r2
JUMP mul_con_wacc
mul_add_wacc:
CALL addlwacc
mul_con_wacc:
CALL shlr1r0
CBR 1 status_reg
CALL shrr3r2
CBR 1 status_reg
DECRJZ t0
JUMP mul_add_start_wacc
RETURN

cpylwacc:
# Loads the wide accumulator with the literal described by r1r0
COPYRR r0 wacc_l
COPYRR r1 wacc_h
RETURN

addlwacc:
# Adds r1r0 to the wide accumulator
COPYRA wacc_l
ADDRA r0
BCRSS 1 status_reg
JUMP addlwacc_no_carry
CALL addlwacc_high
ADDLA 1
COPYAR wacc_h
RETURN
addlwacc_no_carry:
CALL addlwacc_high
COPYAR wacc_h
RETURN 
addlwacc_high:
COPYAR wacc_l
COPYRA wacc_h
ADDRA r1
RETURN

sublwacc:
# Subtracts r1r0 from the wide accumulator
COPYRA wacc_l
SUBRA r0
BCRSS 1 status_reg
JUMP sublwacc_no_carry
CALL sublwacc_high
SUBLA 1
COPYAR wacc_h
RETURN
sublwacc_no_carry:
CALL sublwacc_high
COPYAR wacc_h
RETURN 
sublwacc_high:
COPYAR wacc_l
COPYRA wacc_h
SUBRA r1
RETURN


shlr1r0:
# Shift r1r0 left by 1
CBR 1 status_reg
SHIFTRL r0
SHIFTRL r1
RETURN

shlr3r2:
# Shift r3r2 left by 1
CBR 1 status_reg
SHIFTRL r2
SHIFTRL r3
RETURN

f_push:
# Pushes `r0` to the top of the stack
COPYRR stack_ptr f_to
COPYLR r0 f_from
CALL f_copy_ind
INCR stack_ptr
RETURN

f_pop:
# Pops the top of the stack on to `r0`
DECR stack_ptr
COPYRR stack_ptr f_from
COPYLR r0 f_to
CALL f_copy_ind
RETURN

f_copy_ind:
# Performs an indirect copy between the addresses pointed to by `f_from, f_to`.
# This also shows a "template" function. It is constructed and parametrised in 
# memory prior to being called from the main program.
.DB 7   # COPYRR opcode
f_from:
.DB 0
f_to:
.DB 0
RETURN


# General Registers
r1:
.DB 0
r0:
.DB 0
r3:
.DB 0
r2:
.DB 0
t1:
.DB 0
t0:
.DB 0
t3:
.DB 0
t2:
.DB 0
t5:
.DB 0
t4:
.DB 0

wacc:
wacc_h:
.DB 0
wacc_l:
.DB 0

ascii_str:
.DB 0,0,0,0,0,0

stack_ptr:
.DB 0
stack:
.DB 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
